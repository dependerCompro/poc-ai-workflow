{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref, computed, watch } from 'vue';\nimport { VueFlow, useVueFlow } from '@vue-flow/core';\nimport { Background } from '@vue-flow/background';\nimport { ControlButton, Controls } from '@vue-flow/controls';\nimport { MiniMap } from '@vue-flow/minimap';\nimport Icon from './components/ControlIcons.vue';\nimport SideBar from './components/SideBar.vue';\nimport { useDragAndDropStore } from '@/stores/index.js';\nimport InputPromptNode from '@/components/InputPromptNode.vue';\nimport InputDataNode from '@/components/InputDataNode.vue';\nimport ProcessorNode from '@/components/ProcessorNode.vue';\nimport OutputNode from '@/components/OutputNode.vue';\nexport default {\n  __name: 'App',\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    const {\n      onNodeDragStop,\n      onConnect,\n      setViewport,\n      toObject,\n      screenToFlowCoordinate,\n      onNodeClick,\n      onPaneClick\n    } = useVueFlow();\n    const dark = ref(false);\n    const store = useDragAndDropStore();\n    const nodeCount = ref({\n      \"input-prompt\": 0,\n      \"input-data\": 0,\n      \"processor\": 0,\n      \"result-output\": 0\n    });\n    const draggedType = computed(() => store.draggedType);\n    const isDragging = computed(() => store.isDragging);\n    const isDragOver = computed(() => store.isDragOver);\n    const nodes = computed(() => store.nodes);\n    const edges = computed(() => store.edges);\n    watch(isDragging, dragging => {\n      document.body.style.userSelect = dragging ? 'none' : '';\n    });\n    const toggleDarkMode = () => {\n      dark.value = !dark.value;\n    };\n    const resetTransform = () => {\n      setViewport({\n        x: 0,\n        y: 0,\n        zoom: 1\n      });\n    };\n    const logToObject = () => {\n      console.log(toObject());\n    };\n    const getNewNodeId = type => {\n      const timeStamp = Date.now();\n      return `${timeStamp}-${type}-${nodeCount.value[type]++}`;\n    };\n    const getNewEdgeId = (src, tgt) => {\n      return src + \"___\" + tgt;\n    };\n    const onDrop = event => {\n      event.preventDefault();\n      const vueFlowContainer = event.target.console.log(\"On Drop > Node: \", event);\n      const position = screenToFlowCoordinate({\n        x: event.clientX,\n        y: event.clientY\n      });\n      const nodeId = getNewNodeId(draggedType.value);\n      const newNode = {\n        id: nodeId,\n        type: draggedType.value,\n        position: position,\n        data: {\n          userInput: \"\"\n        }\n      };\n      nodes.value.push(newNode);\n      store.activeNodeId = nodeId;\n    };\n    const onDragOver = event => {\n      event.preventDefault();\n      if (draggedType.value) {\n        store.isDragOver = true;\n        if (event.dataTransfer) {\n          event.dataTransfer.dropEffect = 'move';\n        }\n      }\n    };\n    const onDragLeave = () => {\n      store.isDragOver = false;\n    };\n    onNodeDragStop(({\n      node\n    }) => {\n      nodes.value.forEach(obj => {\n        if (obj.id == node.id) {\n          obj.position = {\n            ...node.position\n          };\n        }\n      });\n    });\n    onConnect(event => {\n      const edgeId = getNewEdgeId(event.source, event.target);\n      const newEdge = {\n        id: edgeId,\n        source: event.source,\n        target: event.target,\n        animated: true\n      };\n      edges.value.push(newEdge);\n    });\n    onNodeClick(event => {\n      store.activeNodeId = event.node.id;\n    });\n    onPaneClick(() => {\n      store.activeNodeId = \"\";\n    });\n    const __returned__ = {\n      onNodeDragStop,\n      onConnect,\n      setViewport,\n      toObject,\n      screenToFlowCoordinate,\n      onNodeClick,\n      onPaneClick,\n      dark,\n      store,\n      nodeCount,\n      draggedType,\n      isDragging,\n      isDragOver,\n      nodes,\n      edges,\n      toggleDarkMode,\n      resetTransform,\n      logToObject,\n      getNewNodeId,\n      getNewEdgeId,\n      onDrop,\n      onDragOver,\n      onDragLeave,\n      ref,\n      computed,\n      watch,\n      get VueFlow() {\n        return VueFlow;\n      },\n      get useVueFlow() {\n        return useVueFlow;\n      },\n      get Background() {\n        return Background;\n      },\n      get ControlButton() {\n        return ControlButton;\n      },\n      get Controls() {\n        return Controls;\n      },\n      get MiniMap() {\n        return MiniMap;\n      },\n      Icon,\n      SideBar,\n      get useDragAndDropStore() {\n        return useDragAndDropStore;\n      },\n      InputPromptNode,\n      InputDataNode,\n      ProcessorNode,\n      OutputNode\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","computed","watch","VueFlow","useVueFlow","Background","ControlButton","Controls","MiniMap","Icon","SideBar","useDragAndDropStore","InputPromptNode","InputDataNode","ProcessorNode","OutputNode","onNodeDragStop","onConnect","setViewport","toObject","screenToFlowCoordinate","onNodeClick","onPaneClick","dark","store","nodeCount","draggedType","isDragging","isDragOver","nodes","edges","dragging","document","body","style","userSelect","toggleDarkMode","value","resetTransform","x","y","zoom","logToObject","console","log","getNewNodeId","type","timeStamp","Date","now","getNewEdgeId","src","tgt","onDrop","event","preventDefault","vueFlowContainer","target","position","clientX","clientY","nodeId","newNode","id","data","userInput","push","activeNodeId","onDragOver","dataTransfer","dropEffect","onDragLeave","node","forEach","obj","edgeId","source","newEdge","animated"],"sources":["D:/poc-ai-workflow/src/App.vue"],"sourcesContent":["<template>\r\n  <SideBar />\r\n  <VueFlow :nodes=\"nodes\" :edges=\"edges\" :class=\"{ dark }\" class=\"basic-flow\" @drop=\"onDrop\" @dragover=\"onDragOver\"\r\n    @dragleave=\"onDragLeave\" :min-zoom=\"0.2\" :max-zoom=\"4\">\r\n    <Background :style=\"{\r\n      backgroundColor: isDragOver ? '#e7f3ff' : 'transparent',\r\n      transition: 'background-color 0.2s ease',\r\n    }\" pattern-color=\"#aaa\" :gap=\"16\" />\r\n\r\n    <MiniMap />\r\n\r\n    <Controls position=\"top-right\">\r\n      <ControlButton title=\"Reset Transform\" @click=\"resetTransform\">\r\n        <Icon name=\"reset\" />\r\n      </ControlButton>\r\n      <ControlButton title=\"Toggle Dark Mode\" @click=\"toggleDarkMode\">\r\n        <Icon v-if=\"dark\" name=\"sun\" />\r\n        <Icon v-else name=\"moon\" />\r\n      </ControlButton>\r\n      <ControlButton title=\"Log `toObject`\" @click=\"logToObject\">\r\n        <Icon name=\"log\" />\r\n      </ControlButton>\r\n    </Controls>\r\n    <template #node-input-prompt>\r\n      <InputPromptNode />\r\n    </template>\r\n    <template #node-input-data>\r\n      <InputDataNode />\r\n    </template>\r\n    <template #node-processor>\r\n      <ProcessorNode />\r\n    </template>\r\n    <template #node-result-output>\r\n      <OutputNode />\r\n    </template>\r\n  </VueFlow>\r\n</template>\r\n\r\n<script setup>\r\nimport { ref, computed, watch } from 'vue'\r\nimport { VueFlow, useVueFlow } from '@vue-flow/core'\r\nimport { Background } from '@vue-flow/background'\r\nimport { ControlButton, Controls } from '@vue-flow/controls'\r\nimport { MiniMap } from '@vue-flow/minimap'\r\nimport Icon from './components/ControlIcons.vue'\r\nimport SideBar from './components/SideBar.vue'\r\nimport { useDragAndDropStore } from '@/stores/index.js';\r\nimport InputPromptNode from '@/components/InputPromptNode.vue';\r\nimport InputDataNode from '@/components/InputDataNode.vue';\r\nimport ProcessorNode from '@/components/ProcessorNode.vue';\r\nimport OutputNode from '@/components/OutputNode.vue';\r\n\r\nconst { onNodeDragStop, onConnect, setViewport, toObject, screenToFlowCoordinate, onNodeClick, onPaneClick } = useVueFlow()\r\n\r\nconst dark = ref(false)\r\nconst store = useDragAndDropStore()\r\nconst nodeCount = ref({\r\n  \"input-prompt\": 0,\r\n  \"input-data\": 0,\r\n  \"processor\": 0,\r\n  \"result-output\": 0\r\n})\r\n\r\nconst draggedType = computed(() => store.draggedType)\r\nconst isDragging = computed(() => store.isDragging)\r\nconst isDragOver = computed(() => store.isDragOver)\r\nconst nodes = computed(() => store.nodes)\r\nconst edges = computed(() => store.edges)\r\n\r\nwatch(isDragging, (dragging) => {\r\n  document.body.style.userSelect = dragging ? 'none' : ''\r\n})\r\n\r\nconst toggleDarkMode = () => {\r\n  dark.value = !dark.value\r\n}\r\n\r\nconst resetTransform = () => {\r\n  setViewport({ x: 0, y: 0, zoom: 1 })\r\n}\r\n\r\nconst logToObject = () => {\r\n  console.log(toObject())\r\n}\r\n\r\nconst getNewNodeId = (type) => {\r\n  const timeStamp = Date.now()\r\n  return `${timeStamp}-${type}-${nodeCount.value[type]++}`\r\n}\r\n\r\nconst getNewEdgeId = (src, tgt) => {\r\n  return src + \"___\" + tgt;\r\n}\r\n\r\nconst onDrop = (event) => {\r\n  event.preventDefault();\r\n\r\n  const vueFlowContainer = event.target.\r\n\r\n  console.log(\"On Drop > Node: \", event);\r\n  const position = screenToFlowCoordinate({\r\n    x: event.clientX,\r\n    y: event.clientY,\r\n  })\r\n  const nodeId = getNewNodeId(draggedType.value)\r\n\r\n  const newNode = {\r\n    id: nodeId,\r\n    type: draggedType.value,\r\n    position: position,\r\n    data: { userInput: \"\" },\r\n  }\r\n  nodes.value.push(newNode)\r\n  store.activeNodeId = nodeId;\r\n}\r\n\r\nconst onDragOver = (event) => {\r\n  event.preventDefault()\r\n  if (draggedType.value) {\r\n    store.isDragOver = true\r\n    if (event.dataTransfer) {\r\n      event.dataTransfer.dropEffect = 'move'\r\n    }\r\n  }\r\n}\r\n\r\nconst onDragLeave = () => {\r\n  store.isDragOver = false\r\n}\r\n\r\nonNodeDragStop(({ node }) => {\r\n  nodes.value.forEach((obj) => {\r\n    if (obj.id == node.id) {\r\n      obj.position = { ...node.position };\r\n    }\r\n  })\r\n})\r\n\r\nonConnect((event) => {\r\n  const edgeId = getNewEdgeId(event.source, event.target);\r\n  const newEdge = {\r\n    id: edgeId,\r\n    source: event.source,\r\n    target: event.target,\r\n    animated: true,\r\n  }\r\n  edges.value.push(newEdge);\r\n})\r\n\r\nonNodeClick((event) => {\r\n  store.activeNodeId = event.node.id;\r\n})\r\n\r\nonPaneClick(() => {\r\n  store.activeNodeId = \"\";\r\n})\r\n</script>\r\n\r\n<style>\r\n@import '@vue-flow/core/dist/style.css';\r\n@import '@vue-flow/core/dist/theme-default.css';\r\n@import './main.css';\r\n\r\n#app {\r\n  display: flex;\r\n}\r\n</style>\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}